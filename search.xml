<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代码整洁之道 - 函数</title>
    <url>/2025/06/30/Clean-Code-Function/</url>
    <content><![CDATA[<h2 id="短小-Small"><a href="#短小-Small" class="headerlink" title="短小 Small"></a>短小 Small</h2><p>函数的第一条规则是要 <strong>短小</strong>，第二条规则是要 <strong>更短小</strong></p>
<ul>
<li>20 行封顶最佳</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">renderPageWithSetupsAndTearDowns</span><span class="params">(PageData pageData, <span class="type">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTestPage(pageData)) &#123;</span><br><span class="line">        includeSetupAndTeardownPages(pageData, isSuite);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="代码块与缩进-Blocks-and-Indenting"><a href="#代码块与缩进-Blocks-and-Indenting" class="headerlink" title="代码块与缩进 Blocks and Indenting"></a>代码块与缩进 Blocks and Indenting</h2><p>if 、else 和 while 语句等，其中的代码块应该只占一行（should be one line long），通常该行是一个函数调用</p>
<ul>
<li><p>函数的缩进层级不该多于一层或两层</p>
</li>
<li><p>这样的函数易于阅读和理解</p>
</li>
</ul>
<h2 id="只做一件事-Do-One-Thing"><a href="#只做一件事-Do-One-Thing" class="headerlink" title="只做一件事 Do One Thing"></a>只做一件事 Do One Thing</h2><ul>
<li><p>函数应该做一件事。做好这件事，只做这一件事。</p>
</li>
<li><p>函数的目的 &#x3D;&gt; 把较大的概念 拆分为 另一抽象层上的 一系列步骤</p>
</li>
<li><p>如果步骤在同一抽象层上，我们就可以认为是同一件事</p>
</li>
<li><p>判断函数可否做了一件事 -&gt; 看其是否可再被拆分出一个函数</p>
</li>
<li><p>只做一件事的函数，无法被合理切分为多个区段</p>
</li>
</ul>
<h2 id="每个函数一个抽象层级-One-Level-of-Abstraction-per-Function"><a href="#每个函数一个抽象层级-One-Level-of-Abstraction-per-Function" class="headerlink" title="每个函数一个抽象层级 One Level of Abstraction per Function"></a>每个函数一个抽象层级 One Level of Abstraction per Function</h2><ul>
<li><p>要确保函数只做一件事，函数中语句必须在同一抽象层级</p>
</li>
<li><p>The Stepdown Rule 向下规则：让代码读起来像是一系列 自顶向下的 TO 开头的段落是保持抽象层级协调一致的有效技巧</p>
</li>
</ul>
<h2 id="Switch-语句-Switch-Statements"><a href="#Switch-语句-Switch-Statements" class="headerlink" title="Switch 语句 Switch Statements"></a>Switch 语句 Switch Statements</h2><p>switch 不可能只做一件事，但我们可以把它埋藏在 <strong>较低</strong> 的抽象层级</p>
<p>解决方案：将 switch 埋藏到 <strong>抽象工厂</strong> 底下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Money <span class="title function_">calculatePay</span><span class="params">(Employee e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMMISSIONED:</span><br><span class="line">            <span class="keyword">return</span> calculateCommissionedPay(e);</span><br><span class="line">        <span class="keyword">case</span> HOURLY:</span><br><span class="line">            <span class="keyword">return</span> calculateHourlyPay(e);</span><br><span class="line">        <span class="keyword">case</span> SALARIED:</span><br><span class="line">            <span class="keyword">return</span> calculateSalariedPay(e);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidOperation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数有几个问题：</p>
<ol>
<li><p>太长，出现新的雇员类型时会更长</p>
</li>
<li><p>明显做了不止一件事</p>
</li>
<li><p>违反了单一职责原则，因为有好几个可以修改它的理由</p>
</li>
<li><p>违反了开闭原则，每当添加新类型时，必须修改该函数</p>
</li>
</ol>
<p>更好的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">isPayDay</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Money <span class="title function_">calculatePay</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">deliverPay</span><span class="params">(Money pay)</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IEmployeeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">makeEmployee</span><span class="params">(EmployeeRecord r)</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line"><span class="keyword">public</span> EmployeeFactory : IEmployeeFactory &#123;</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">makeEmployee</span><span class="params">(EmployeeRecord r)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (r.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> COMMISSIONED:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommissionedEmployee</span>(r);</span><br><span class="line">            <span class="keyword">case</span> HOURLY:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HourlyEmployee</span>(r);</span><br><span class="line">            <span class="keyword">case</span> SALARIED:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SalariedEmployee</span>(r);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidOperation</span>();            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用具有描述性的名称-Use-Descriptive-Names"><a href="#使用具有描述性的名称-Use-Descriptive-Names" class="headerlink" title="使用具有描述性的名称 Use Descriptive Names"></a>使用具有描述性的名称 Use Descriptive Names</h2><ul>
<li><p>函数越短小，功能越集中，越便于起个好名字</p>
</li>
<li><p>长而具有描述性的名称 比 短而令人费解的名称 好</p>
</li>
<li><p>长而具有描述性的名称 比 描述性的长注释 好</p>
</li>
<li><p>描述性的名称 能理清 你关于模块 的设计思路</p>
</li>
<li><p>命名方式要保持一致</p>
</li>
</ul>
<h2 id="函数参数-Function-Arguments"><a href="#函数参数-Function-Arguments" class="headerlink" title="函数参数 Function Arguments"></a>函数参数 Function Arguments</h2><ul>
<li><p>最理想的参数个数是 0，其次是 1，再次是 2</p>
</li>
<li><p>尽量避免3，有足够的理由才能用3个以上的参数</p>
</li>
<li><p>参数与函数处于不同的抽象层级，要求你了解目前并不重要的细节</p>
</li>
<li><p>尽量不要用输出参数，一般情况下难以理解</p>
</li>
</ul>
<h3 id="单参数函数的普遍形式-Common-Monadic-Forms"><a href="#单参数函数的普遍形式-Common-Monadic-Forms" class="headerlink" title="单参数函数的普遍形式 Common Monadic Forms"></a>单参数函数的普遍形式 Common Monadic Forms</h3><ul>
<li><p>问关于参数的问题 <code>bool fileExists(&quot;MyFile&quot;)</code></p>
</li>
<li><p>操作参数，转换为其他的东西 <code>InputStream fileOpen(&quot;MyFile&quot;)</code></p>
</li>
<li><p>事件 Event，程序将函数看成一个事件，使用该参数修改系统状态</p>
</li>
<li><p>尽量避免编写不遵循这些形式的单参数函数</p>
</li>
</ul>
<h3 id="标识参数-Flag-Arguments"><a href="#标识参数-Flag-Arguments" class="headerlink" title="标识参数 Flag Arguments"></a>标识参数 Flag Arguments</h3><p>标识参数是丑陋的，一旦用了标识参数，意味着一定违反了SRP，此时应该拆分函数</p>
<h3 id="双参数函数-Dyadic-Functions"><a href="#双参数函数-Dyadic-Functions" class="headerlink" title="双参数函数 Dyadic Functions"></a>双参数函数 Dyadic Functions</h3><p>尽量利用一些机制将其转换成单参数函数</p>
<h3 id="三参数函数-Triads"><a href="#三参数函数-Triads" class="headerlink" title="三参数函数 Triads"></a>三参数函数 Triads</h3><p>在写三参数函数前一定要想清楚</p>
<h3 id="参数对象-Argument-Objects"><a href="#参数对象-Argument-Objects" class="headerlink" title="参数对象 Argument Objects"></a>参数对象 Argument Objects</h3><p>如果函数看起来需要超过2个以上参数，此时就意味着其中一些参数应该被封装成类了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Circle <span class="title function_">makeCircle</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y, <span class="type">double</span> radius)</span>;</span><br><span class="line">Circle <span class="title function_">makeCircle</span><span class="params">(Point center, <span class="type">double</span> radius)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="参数列表-Argument-Lists"><a href="#参数列表-Argument-Lists" class="headerlink" title="参数列表 Argument Lists"></a>参数列表 Argument Lists</h3><p>略</p>
<h3 id="动词与关键字-Verbs-and-Keywords"><a href="#动词与关键字-Verbs-and-Keywords" class="headerlink" title="动词与关键字 Verbs and Keywords"></a>动词与关键字 Verbs and Keywords</h3><p>对于单参数函数，函数和参数应当形成一种非常良好的动词&#x2F;名词对形式，例如 <code>write(name)</code>. 更好的名称也可以是 <code>writeField(name)</code> ，这告诉我们 name 是一个 field</p>
<h2 id="无副作用-Have-No-Side-Effects"><a href="#无副作用-Have-No-Side-Effects" class="headerlink" title="无副作用 Have No Side Effects"></a>无副作用 Have No Side Effects</h2><p>副作用是一种谎言，函数承诺做一件事，却悄悄地做了另一件事。这会造成意料之外的影响如：</p>
<ol>
<li><p>古怪的时序性耦合</p>
</li>
<li><p>顺序依赖</p>
</li>
</ol>
<p>函数名一定要能体现其要做的事</p>
<h3 id="输出参数-Output-Arguments"><a href="#输出参数-Output-Arguments" class="headerlink" title="输出参数 Output Arguments"></a>输出参数 Output Arguments</h3><ul>
<li><p>如果你被迫检查函数签名，就得花时间做一些重构，应该避免这种中断思路的事</p>
</li>
<li><p>应避免使用输出参数，因为 this 也有输出的意味</p>
</li>
<li><p>如果函数必须要修改某种状态，就修改所属对象的状态</p>
</li>
</ul>
<h2 id="分隔指令与询问-Command-Query-Separation"><a href="#分隔指令与询问-Command-Query-Separation" class="headerlink" title="分隔指令与询问 Command Query Separation"></a>分隔指令与询问 Command Query Separation</h2><ul>
<li>函数要么做什么事，要么回答什么事，二者不可兼得</li>
</ul>
<h2 id="使用异常替代返回错误码-Prefer-Exception-to-Returning-Error-Codes"><a href="#使用异常替代返回错误码-Prefer-Exception-to-Returning-Error-Codes" class="headerlink" title="使用异常替代返回错误码 Prefer Exception to Returning Error Codes"></a>使用异常替代返回错误码 Prefer Exception to Returning Error Codes</h2><ul>
<li><p>从指令式函数返回错误码略微违反了指令与询问分隔的原则</p>
</li>
<li><p>如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，如：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeyd.deleteKey(page.name.makeKey());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.log(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽离-try-catch-代码块-Extract-Try-Catch-Blocks"><a href="#抽离-try-catch-代码块-Extract-Try-Catch-Blocks" class="headerlink" title="抽离 try&#x2F;catch 代码块 Extract Try&#x2F;Catch Blocks"></a>抽离 try&#x2F;catch 代码块 Extract Try&#x2F;Catch Blocks</h3><p>try&#x2F;catch 代码块，把错误处理与正常流程混为一谈， 最好把 try 和 catch 代码块的主体部分抽离出来，另外形成函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Page page)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        deletePageAndAllReferences(page);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deletePageAndAllReferences</span><span class="params">(Page page)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    deletePage(page);</span><br><span class="line">    registry.deleteReference(page.name);</span><br><span class="line">    configKeys.deleteKey(page.name.makeKey());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logError</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">    logger.log(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例中：</p>
<ul>
<li><p><code>delete</code> 函数只与错误处理有关</p>
</li>
<li><p><code>deletePageAndAllReferences</code> 只与完全删除一个page有关，不用管错误处理</p>
</li>
</ul>
<h3 id="错误处理就是一件事-Error-Handling-Is-One-Thing"><a href="#错误处理就是一件事-Error-Handling-Is-One-Thing" class="headerlink" title="错误处理就是一件事 Error Handling Is One Thing"></a>错误处理就是一件事 Error Handling Is One Thing</h3><p>函数应该只做一件事，错误处理就是一件事，这意味着：</p>
<p>如果在某个函数中存在 <code>try</code>，它就应该是这个函数的第一个单词，且在 <code>catch/finally</code> 代码块后面也不该有其他内容。</p>
<h3 id="Error-java-依赖磁铁-The-Error-java-Dependency-Magnet"><a href="#Error-java-依赖磁铁-The-Error-java-Dependency-Magnet" class="headerlink" title="Error.java 依赖磁铁 The Error.java Dependency Magnet"></a>Error.java 依赖磁铁 The Error.java Dependency Magnet</h3><p>返回错误通常定义成一个类或枚举，很多其他类都会导入和使用它，意味着：</p>
<p>当修改 Error.java 时，所有其他类都需要重新编译和部署 - 这是不好的一面</p>
<h2 id="别重复自己-Do-not-Repeat-Yourself"><a href="#别重复自己-Do-not-Repeat-Yourself" class="headerlink" title="别重复自己 Do not Repeat Yourself"></a>别重复自己 Do not Repeat Yourself</h2><p>重复可能是软件中一些邪恶的根源，许多原则和实践规则都是为了控制与消除重复而创建的</p>
<p>例如：</p>
<ul>
<li><p>Codd 数据库范式就是为了消除数据重复而服务的</p>
</li>
<li><p>面向对象编程把代码集中到基类，从而避免冗余</p>
</li>
<li><p>面向切面编程、面向组件编程，多少也是为了消除重复的一种策略</p>
</li>
</ul>
<h2 id="结构化编程-Structured-Programming"><a href="#结构化编程-Structured-Programming" class="headerlink" title="结构化编程 Structured Programming"></a>结构化编程 Structured Programming</h2><p>这是 Edsger Dijkstra 提出的编程规则：每个函数、函数中的每个代码块都应该有一个入口，一个出口，遵循该原则，意味着：</p>
<ul>
<li><p>每个函数只该有一个 <code>return</code> 语句</p>
</li>
<li><p>循环中不能有 <code>break</code> 或 <code>continue</code> 语句</p>
</li>
<li><p>永远不能有任何 <code>goto</code> 语句</p>
</li>
</ul>
<p>但是，对于小函数，这些规则助益不大，所以尽量保持函数短小，偶尔出现的 <code>return</code> <code>break</code> 和 <code>continue</code> 语句没有坏处</p>
<h2 id="小结-Conclusion"><a href="#小结-Conclusion" class="headerlink" title="小结 Conclusion"></a>小结 Conclusion</h2><ul>
<li><p>不要指望一开始就按规则写函数</p>
</li>
<li><p>先写出来，用尽量完备的测试覆盖每行代码</p>
</li>
<li><p>打磨代码，分解函数，修改名称，消除重复</p>
</li>
<li><p>编程艺术是且一直是语言设计的艺术</p>
</li>
<li><p>大师级程序员把系统当作故事来讲，而不是当作程序来写</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Engineering</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>代码整洁之道 - 有意义的命名</title>
    <url>/2025/06/29/Clean-Code-Naming/</url>
    <content><![CDATA[<h2 id="名副其实-Use-Intention-Revealing-Names"><a href="#名副其实-Use-Intention-Revealing-Names" class="headerlink" title="名副其实 Use Intention-Revealing Names"></a>名副其实 Use Intention-Revealing Names</h2><p>如下是较好的例子（既有计量对象，也有计量单位）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> elapsedTimInDays;</span><br><span class="line"><span class="type">int</span> daysSinceCreation;</span><br><span class="line"><span class="type">int</span> daysSinceModification;</span><br><span class="line"><span class="type">int</span> fileAgeInDays;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="避免误导-Avoid-Disinformation"><a href="#避免误导-Avoid-Disinformation" class="headerlink" title="避免误导 Avoid Disinformation"></a>避免误导 Avoid Disinformation</h2><ul>
<li><p>不要滥用 List、Array，它们有特定的含义，当形容一群&#x2F;组东西时，要仔细思考是否要提及数据结构。</p>
</li>
<li><p>提防使用外形相似度高的名称，当两个命名长度很长且相似时，区分它们要花时间</p>
</li>
<li><p>在代码中，对同一概念或实体必须使用完全一致的命名和表达方式，才能传递清晰、无歧义的信息</p>
<ul>
<li><p>如混用 <code>start/begin</code>  <code>get/fetch</code>  <code>controller/manager</code> 等相似术语</p>
</li>
<li><p>统一使用 <code>start</code> 表示启动，<code>get</code> 表示获取</p>
</li>
</ul>
</li>
<li><p>不要用 <strong>小写字母 l</strong> 和 <strong>大写字母 O</strong> 作变量名</p>
</li>
</ul>
<h2 id="做有意义的区分-Make-Meaningful-Distinctions"><a href="#做有意义的区分-Make-Meaningful-Distinctions" class="headerlink" title="做有意义的区分 Make Meaningful Distinctions"></a>做有意义的区分 Make Meaningful Distinctions</h2><ul>
<li>不要用数字系列命名 Number-series naming (a1, a2, .. aN) is the opposite of intentional naming</li>
<li>不要说废话<ul>
<li>如类名叫 Product，又出现一个 ProductInfo 或 ProductData 的类，虽然它们名称不同，含义却无区别。类似的还有 Customer 和 CustomerObject</li>
<li>variable不要出现在变量名中，table不要出现在表名中</li>
</ul>
</li>
</ul>
<h2 id="使用能读出来的名称-Use-Pronounceable-Names"><a href="#使用能读出来的名称-Use-Pronounceable-Names" class="headerlink" title="使用能读出来的名称 Use Pronounceable Names"></a>使用能读出来的名称 Use Pronounceable Names</h2><ul>
<li><p>编程是一种社交活动，如果读不出来如何讨论？</p>
<ul>
<li>反例：变量名 genymdhms (generation date, year, month, day, hour, minute,<br>and second)，how to pronounce?</li>
</ul>
</li>
</ul>
<h2 id="使用可搜索的名称-Use-Searchable-Names"><a href="#使用可搜索的名称-Use-Searchable-Names" class="headerlink" title="使用可搜索的名称 Use Searchable Names"></a>使用可搜索的名称 Use Searchable Names</h2><p>对于单字母名称和数字常量，很难搜到，比如 搜索 数字7 很麻烦，但搜 MAX_CLASSES_PER_STUDENT 很容易。</p>
<ul>
<li>名称长度应与其作用域大小相对应</li>
</ul>
<h2 id="避免使用编码-Avoid-Encodings"><a href="#避免使用编码-Avoid-Encodings" class="headerlink" title="避免使用编码 Avoid Encodings"></a>避免使用编码 Avoid Encodings</h2><h3 id="匈牙利语标记法-Hungarian-Notation-HN"><a href="#匈牙利语标记法-Hungarian-Notation-HN" class="headerlink" title="匈牙利语标记法 Hungarian Notation, HN"></a>匈牙利语标记法 Hungarian Notation, HN</h3><p>这种命名法要求明确写出类型，类型置于实际名称前，如 bBuzy 代表类型为 boolean、名称为 Busy 的变量</p>
<p>现在这种编码形式纯属多余</p>
<h3 id="成员前缀-Member-Prefixes"><a href="#成员前缀-Member-Prefixes" class="headerlink" title="成员前缀 Member Prefixes"></a>成员前缀 Member Prefixes</h3><p>不必用 m_ 前缀标明成员变量</p>
<h3 id="接口与实现-Interfaces-and-Implementations"><a href="#接口与实现-Interfaces-and-Implementations" class="headerlink" title="接口与实现 Interfaces and Implementations"></a>接口与实现 Interfaces and Implementations</h3><ul>
<li><p>ShapeFactory n ShapeFactoryImp 推荐</p>
</li>
<li><p>IShapeFactory n ShapeFactory 不推荐，I 被滥用，但是还是看团队吧</p>
</li>
</ul>
<h2 id="避免思维映射-Avoid-Mental-Mapping"><a href="#避免思维映射-Avoid-Mental-Mapping" class="headerlink" title="避免思维映射 Avoid Mental Mapping"></a>避免思维映射 Avoid Mental Mapping</h2><p>经常出现在使用 问题领域术语(problem domain terms) 还是 解决方案领域术语 (solution domain terms)</p>
<p>明确是王道，编写的代码要易于理解</p>
<h2 id="类名-Class-Names"><a href="#类名-Class-Names" class="headerlink" title="类名 Class Names"></a>类名 Class Names</h2><ul>
<li><p>应该是 名词 或 名词短语，如 Customer、WikiPage、Account and AddressParser</p>
</li>
<li><p>反例：Manager、Processor、Data、Info</p>
</li>
<li><p>类名不应是动词</p>
</li>
</ul>
<h2 id="方法名-Method-Names"><a href="#方法名-Method-Names" class="headerlink" title="方法名 Method Names"></a>方法名 Method Names</h2><ul>
<li><p>应当是 动词 或 动词短语，如 postPayment、deletePage 或 save</p>
</li>
<li><p>使用描述了参数的静态工厂方法名重载构造器，把构造器设置为 private</p>
</li>
</ul>
<h2 id="别抖机灵-Do-not-Be-Cute"><a href="#别抖机灵-Do-not-Be-Cute" class="headerlink" title="别抖机灵 Do not Be Cute"></a>别抖机灵 Do not Be Cute</h2><ul>
<li><p>别用 HolyHandGrenade，使用 DeleteItems。明确含义</p>
</li>
<li><p>别用 whack() 表示 kill(), Say what you mean. Mean what you say</p>
</li>
</ul>
<h2 id="每个概念对应一个词-Pick-One-Word-per-Concept"><a href="#每个概念对应一个词-Pick-One-Word-per-Concept" class="headerlink" title="每个概念对应一个词 Pick One Word per Concept"></a>每个概念对应一个词 Pick One Word per Concept</h2><p>跟避免误导里某一项比较类似，就是说给 <strong>每个抽象概念</strong> 选 <strong>一个词</strong>，并一以贯之</p>
<p>例如，同时使用 fetch、retrieve 和 get 在多个类中的同种方法命名，会令人困惑</p>
<p>一以贯之的命名法是天降福音</p>
<h2 id="别用双关语-Do-not-Pun"><a href="#别用双关语-Do-not-Pun" class="headerlink" title="别用双关语 Do not Pun"></a>别用双关语 Do not Pun</h2><p>避免将同一单词用于不同目的，同一个术语用于多个不同概念，就是双关语</p>
<h2 id="使用解决方案领域名称-Use-Solution-Domain-Names"><a href="#使用解决方案领域名称-Use-Solution-Domain-Names" class="headerlink" title="使用解决方案领域名称 Use Solution Domain Names"></a>使用解决方案领域名称 Use Solution Domain Names</h2><p>优先使用 解决方案领域名称。你的读者是程序员，所以尽可能用计算机科学&#x2F;工程相关术语，多用技术性的名称，如：</p>
<ul>
<li><p>AccountVisitor 对于熟悉 访问者(Visitor)模式的程序员就很友好</p>
</li>
<li><p>JobQueue，我们知道这是个任务队列</p>
</li>
</ul>
<h2 id="使用问题领域名称-Use-problem-Domain-Names"><a href="#使用问题领域名称-Use-problem-Domain-Names" class="headerlink" title="使用问题领域名称 Use problem Domain Names"></a>使用问题领域名称 Use problem Domain Names</h2><p>如果不好用 解决方案领域名称，就从所涉问题领域寻找名称。至少这个名称你可以从领域专家那知道其含义</p>
<h2 id="添加有意义的语境-Add-Meaningful-Context"><a href="#添加有意义的语境-Add-Meaningful-Context" class="headerlink" title="添加有意义的语境 Add Meaningful Context"></a>添加有意义的语境 Add Meaningful Context</h2><h2 id="不要添加没用的语境-Do-not-Add-Gratuitous-Context"><a href="#不要添加没用的语境-Do-not-Add-Gratuitous-Context" class="headerlink" title="不要添加没用的语境 Do not Add Gratuitous Context"></a>不要添加没用的语境 Do not Add Gratuitous Context</h2><p>只要短名称足够清楚，就比长名称好，别给名称添加没用的语境</p>
<h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结 Conclusion"></a>总结 Conclusion</h2><p>明确 &amp; 简洁 &amp; 一以贯之 &amp; 优先解决方案领域</p>
]]></content>
      <categories>
        <category>Engineering</category>
      </categories>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 创建型 - 工厂方法模式</title>
    <url>/2025/07/04/Design-Pattern-Factory/</url>
    <content><![CDATA[<h2 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型 Type"></a>类型 Type</h2><ul>
<li>创建型   Creational</li>
</ul>
<h2 id="含义-Intent"><a href="#含义-Intent" class="headerlink" title="含义 Intent"></a>含义 Intent</h2><p>The intent of the factory method pattern is to define an interface for creating an object, but to let subclasses decide which class to instantiate. Factory method lets a class defer  instantiation to subclasses.</p>
<span id="more"></span>

<h2 id="代码-Code"><a href="#代码-Code" class="headerlink" title="代码 Code"></a>代码 Code</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">DiscountService</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    public abstract <span class="type">int</span> DiscountPercentage &#123; get; &#125;</span><br><span class="line">    public override <span class="built_in">string</span> <span class="title function_">ToString</span><span class="params">()</span> =&gt; GetType().Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class <span class="title function_">CountryDiscountService</span><span class="params">(<span class="built_in">string</span> countryId)</span> : DiscountService</span><br><span class="line">&#123;</span><br><span class="line">    public override <span class="type">int</span> DiscountPercentage</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> countryId <span class="keyword">switch</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;BE&quot;</span> =&gt; <span class="number">20</span>,</span><br><span class="line">                _ =&gt; <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class <span class="title function_">CodeDiscountService</span><span class="params">(Guid code)</span> : DiscountService</span><br><span class="line">&#123;</span><br><span class="line">    public override <span class="type">int</span> DiscountPercentage =&gt; <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">DiscountFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    public abstract DiscountService <span class="title function_">CreateDiscountService</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class <span class="title function_">CountryDiscountFactory</span><span class="params">(<span class="built_in">string</span> countryId)</span> : DiscountFactory</span><br><span class="line">&#123;</span><br><span class="line">    public override DiscountService <span class="title function_">CreateDiscountService</span><span class="params">()</span> =&gt; new CountryDiscountService(countryId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class <span class="title function_">CodeDiscountFactory</span><span class="params">(Guid code)</span> : DiscountFactory</span><br><span class="line">&#123;</span><br><span class="line">    public override DiscountService <span class="title function_">CreateDiscountService</span><span class="params">()</span> =&gt; new CodeDiscountService(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client Invoke</span></span><br><span class="line">List&lt;DiscountFactory&gt; factories =</span><br><span class="line">[</span><br><span class="line">    new CountryDiscountFactory(<span class="string">&quot;BE&quot;</span>),</span><br><span class="line">    new CodeDiscountFactory(Guid.NewGuid())</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">foreach (var factory in factories)</span><br><span class="line">&#123;</span><br><span class="line">    var discountService = factory.CreateDiscountService();</span><br><span class="line">    Console.WriteLine(</span><br><span class="line">        $<span class="string">&quot;Discount Service: &#123;discountService&#125;, Discount Percentage: &#123;discountService.DiscountPercentage&#125;%&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用时机-Time-to-Use"><a href="#使用时机-Time-to-Use" class="headerlink" title="使用时机 Time to Use"></a>使用时机 Time to Use</h2><ul>
<li><p>When there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point</p>
</li>
<li><p>When the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code</p>
</li>
</ul>
<h2 id="用例-User-Case"><a href="#用例-User-Case" class="headerlink" title="用例 User Case"></a>用例 User Case</h2><ul>
<li><p>管理数据库连接池 connection pool</p>
</li>
<li><p>缓存 cache</p>
</li>
<li><p>管理应用配置 manage application configuration</p>
</li>
<li><p>通用资源管理 general resource management</p>
</li>
</ul>
<h2 id="模式好坏-Pattern-Consequence"><a href="#模式好坏-Pattern-Consequence" class="headerlink" title="模式好坏 Pattern Consequence"></a>模式好坏 Pattern Consequence</h2><ul>
<li><p>违反了单一职责 Violates the SRP</p>
<ul>
<li><p>负责对象的创建 Control Creation</p>
</li>
<li><p>负责对象的生命周期管理 manage own lifecycle</p>
</li>
</ul>
</li>
<li><p>严格的控制客户对其的访问 Strict Control over how and when clients access it</p>
</li>
<li><p>Avoids polluting the namespace with global variables</p>
</li>
<li><p>Subclassing allows configuring the application with an instance of the class you need at runtime</p>
</li>
<li><p>Multipe instances can be allowed without having to alter the client</p>
</li>
<li><p>很多时候我们不用自己实现，让 IoC 容器管理吧</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Engineering</category>
      </categories>
      <tags>
        <tag>Coding</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 创建型 - 单例模式</title>
    <url>/2025/07/02/Design-Pattern-Singleton/</url>
    <content><![CDATA[<h2 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型 Type"></a>类型 Type</h2><ul>
<li>创建型   Creational</li>
</ul>
<h2 id="含义-Intent"><a href="#含义-Intent" class="headerlink" title="含义 Intent"></a>含义 Intent</h2><p>The intent of the singleton pattern is to ensure that a class only has one instance, and to provide a global point of access to it.</p>
<span id="more"></span>

<h2 id="例子-Real-Example"><a href="#例子-Real-Example" class="headerlink" title="例子 Real Example"></a>例子 Real Example</h2><p>Logger，通常来说应用中只会有一个，以避免意想不到的结果。</p>
<h2 id="代码-Code"><a href="#代码-Code" class="headerlink" title="代码 Code"></a>代码 Code</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Logger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;Logger&gt; lazyLogger = <span class="keyword">new</span> Lazy&lt;Logger&gt;(() =&gt; <span class="keyword">new</span> Logger());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger Instance =&gt; lazyLogger.Value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Logger</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">// SingletonOperation</span></span><br><span class="line">    <span class="comment">// &lt;/summary&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Log: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用时机-Time-to-Use"><a href="#使用时机-Time-to-Use" class="headerlink" title="使用时机 Time to Use"></a>使用时机 Time to Use</h2><ul>
<li><p>When there must be exactly one instance of a class, and it must be accessible to clients from a well-known access point</p>
</li>
<li><p>When the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their code</p>
</li>
</ul>
<h2 id="用例-User-Case"><a href="#用例-User-Case" class="headerlink" title="用例 User Case"></a>用例 User Case</h2><ul>
<li><p>管理数据库连接池 connection pool</p>
</li>
<li><p>缓存 cache</p>
</li>
<li><p>管理应用配置 manage application configuration</p>
</li>
<li><p>通用资源管理 general resource management</p>
</li>
</ul>
<h2 id="模式好坏-Pattern-Consequence"><a href="#模式好坏-Pattern-Consequence" class="headerlink" title="模式好坏 Pattern Consequence"></a>模式好坏 Pattern Consequence</h2><ul>
<li><p>违反了单一职责 Violates the SRP</p>
<ul>
<li><p>负责对象的创建 Control Creation</p>
</li>
<li><p>负责对象的生命周期管理 manage own lifecycle</p>
</li>
</ul>
</li>
<li><p>严格的控制客户对其的访问 Strict Control over how and when clients access it</p>
</li>
<li><p>Avoids polluting the namespace with global variables</p>
</li>
<li><p>Subclassing allows configuring the application with an instance of the class you need at runtime</p>
</li>
<li><p>Multipe instances can be allowed without having to alter the client</p>
</li>
<li><p>很多时候我们不用自己实现，让 IoC 容器管理吧</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Engineering</category>
      </categories>
      <tags>
        <tag>Coding</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 基础</title>
    <url>/2025/06/29/Hexo-Basic/</url>
    <content><![CDATA[<p>本篇记录一些 Hexo 常用的命令，备忘。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="本地启动服务"><a href="#本地启动服务" class="headerlink" title="本地启动服务"></a>本地启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="部署到远程"><a href="#部署到远程" class="headerlink" title="部署到远程"></a>部署到远程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="新建文章头模板"><a href="#新建文章头模板" class="headerlink" title="新建文章头模板"></a>新建文章头模板</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: Hexo 常用命令</span><br><span class="line">date: 2025-06-29 14:20:19</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> Tool</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> Hexo</span><br></pre></td></tr></table></figure>

<h3 id="See-more"><a href="#See-more" class="headerlink" title="See more"></a>See more</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
